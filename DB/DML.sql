insert into quest (quest, answer) 
values ('Что такое SOLID', 
'SOLID - это акроним, каждая буква которого, означает один из основных принципов ООП и дизайна приложений, помогающих строить понятные, гибкие и масштабируемые со временем, решения.

S (Single responsibility principle/Принцип единственной ответственности).

Суть этого принципа сводится к тому, что каждый объект приложения (например, класс или модуль) должен выполнять одну конкретную функцию или обязанность. Для того, чтобы в случае необходимости изменения одной части функциональности не затронуть остальные, работающие и отлаженные ее части.

Например, если один класс выполняет функции по добавлению товаров в каталог (1), расчет скидок на товары в зависимости от сезона (2) и построение отчетов, то лучше разделить эти 3 функции по 3 различным классам.

O (Open/Closed / Открыт/Закрыт).

Значение этого принципа заключается в том, что объекты программного решения должны быть открыты для расширения, но закрыты для модификации.

То есть должна быть возможность добавлять новую функциональность, не изменяя существующие классы.

Это достигается путем использования абстракций (Интерфейсов и абстрактных классов), а также наследования и композиции, то есть сведение в один большой класс несколько меньших.

Например, если есть класс для расчета площади геометрических фигур, то при добавлении новой фигуры, не нужно будет менять сам этот класс, а создать новый, наследуемый от него.

L (Liski Substitution Principle / Принцип подстановки Лиски)

Этот принцип означает, что дочерние классы должны поддерживать структуру базового (родительского) класса таким образом, чтобы при подстановке в код дочернего класса вместо родительского, работа приложения не нарушалась. То есть дочерний класс должен содержать все атрибуты и методы родительского. 

Например, если есть класс Птицы и у него два подкласса Ворона и Пингвин, то Пингвин не будет обладать методом Летать, так как является нелетающим существом. Вместо этого лучше создать один общий класс Животные и внутри него два класса Летающие и Нелетающие.

I (Interface Segregation Principle / Принцип разделения интерфейсов)

Лучше иметь много небольших интерфейсов, чем один общий, большой. Если класс реализует большой интерфейс, но ему нужна только часть его методов, он будет вынужден реализовывать и те методы, которые ему не нужны (через заглушки или инициализацию исключений).

D (Dependency Inversion Principle \ Принцип инверсии зависимостей)

Высокоуровневые компоненты кода, реализующие бизнес логику не должны быть связаны напрямую с низкоуровневыми компонентами, реализующими конкретную механику (например, соединение с конкретным типом БД), а должны быть соединены через абстракцию (например, интерфейс БД, на основе которого уже выполняются конкретные реализации подключений). Пример с Поваром и Плитой.'),
('Охаратеризуйте принципы ACID', 'Принципы ACID - это 4 фундаментальных свойства в системах управления базами данных.

A (Atomicity) - Атомарность. Транзакция либо выполняется полностью либо не выполняется вовсе, независимо от того, из какого количества операций она состоит.

C (Consistency) - Согласованность. СУБД гарантирует, что БД в результате выполнения транзакции будет переведена из одного валидного (согласованного) состояния в другое с соблюдением всех ограничений, наложенных на данные, либо буде отменена полностью.

I (Isolation) - Изоляция. Механизм согласования параллельного выполнения транзакций. Имеет 4 уровня строгости:

1. Uncommitted Read (Чтение незафиксированных данных). Одна транзакция может читать незафиксированные данные другой транзакции. Но здесь может возникнуть дефект "Грязное чтение". Это когда транзакция, опираясь на незафиксированные данные, производит их изменение и фиксирует результат в БД до того, как эти данные были зафиксированы параллельной транзакцией. А транзакция, на основе которой были произведены такие изменения данных, их не фиксирует, а откатывается. В результате итоговые данные в БД оказываются неверными.

2. Committed Read (Чтение зафиксированных данных). Транзакция опирается на данные, которые уже зафиксированы в БД, несмотря на то, что могут быть открыты параллельные транзакции, обрабатывающие те же данные. Здесь уже может возникнуть дефект "Неповторяющееся чтение". Это когда в процессе обработки данных одной транзакцией, данные могут быть изменены и зафиксированы в БД другой транзакцией. И тогда при повторном чтении из БД, будет получен совсем другой результат.

Например, транзакция 1 прочитала данные о цене товара из БД, которая была равна 1000 рублей. Потом параллельная транзакция изменила эту цену на 500. Теперь при повторном чтении цена уже будет не 1000, а 500. И если транзакция 1 произвела какие-то вычисления, на основе прежней цены, то они оказываются неверными при повторном обращении за данными.

Сейчас это стандартный уровень изоляции, с которым работает по умолчанию большинство СУБД.

3. Repeated Read (Повторяющееся чтение). Данные, выбранные из БД фиксируются для конкретной транзакции. То есть, даже если фактически в БД эти данные были изменены, для выбравшей из транзакции они остаются неизменными на всем протяжении ее жизни. Здесь возможно возникновение такого дефекта как "Фантомное чтение". Например, при генерации отчета, посчитана сумма, но если после этого ее пересчитать, значение получится другое, так как в процессе эти данные были изменены параллельной транзакцией.

4. Serializable - Сериализация. При этом уровне изоляции все транзакции выстраиваются в очередь и каждая последующая транзакция может быть выполнена только после того как закончится предыдущая. Это самый надежный способ выполнения транзакций, но самый медленный.

D (Durability) - Долговечность. После фиксации изменений в БД СУБД гарантирует, что они сохранены. Это достигается с помощью механизма упреждающего журналирования (Write Ahead Logging), заключающегося в том, что в начале изменения данных оперативно фиксируются в журнале операций и только потом переносятся непосредственно в таблицы БД.');